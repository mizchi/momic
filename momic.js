// Generated by CoffeeScript 1.7.1
(function() {
  var Momic, applyHooks, defer, dequal, uuid,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  defer = function(f) {
    return new Promise((function(_this) {
      return function(done, reject) {
        return f(done, reject);
      };
    })(this));
  };

  uuid = (function(_this) {
    return function() {
      var s4;
      s4 = function() {
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
      };
      return s4() + s4() + s4() + s4();
    };
  })(this);

  
function clone(obj) {
    if (null == obj || "object" != typeof obj) return obj;
    var copy = obj.constructor();
    for (var attr in obj) {
        if (obj.hasOwnProperty(attr)) copy[attr] = obj[attr];
    }
    return copy;
}
;

  dequal = function(left, right) {
    var i, isLeftPrimitive, isRightPrimitive, key, results, _ref, _ref1;
    isLeftPrimitive = (_ref = typeof left) === 'string' || _ref === 'number' || _ref === 'boolean' || _ref === 'undefined';
    isRightPrimitive = (_ref1 = typeof right) === 'string' || _ref1 === 'number' || _ref1 === 'boolean' || _ref1 === 'undefined';
    if (isLeftPrimitive && isRightPrimitive) {
      return left === right;
    }
    if (isLeftPrimitive || isRightPrimitive) {
      return false;
    }
    results = (function() {
      var _i, _len, _results, _results1;
      if (left instanceof Array) {
        _results = [];
        for (_i = 0, _len = left.length; _i < _len; _i++) {
          i = left[_i];
          _results.push(dequal(left[i], right[i]));
        }
        return _results;
      } else if (left instanceof Object) {
        _results1 = [];
        for (key in left) {
          _results1.push(dequal(left[key], right[key]));
        }
        return _results1;
      }
    })();
    return (results.filter(function(item) {
      return item;
    })).length === results.length;
  };

  applyHooks = function(items, hooks) {
    var hook, i, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = items.length; _i < _len; _i++) {
      i = items[_i];
      _results.push((function() {
        var _j, _len1, _results1;
        _results1 = [];
        for (_j = 0, _len1 = hooks.length; _j < _len1; _j++) {
          hook = hooks[_j];
          _results1.push(hook(i));
        }
        return _results1;
      })());
    }
    return _results;
  };

  Momic = {};

  Momic.Collection = (function() {
    Collection.dequal = dequal;

    Collection.prototype.addPlugin = function(_arg) {
      var initialize, postSaveHook, preInsertHook, preSaveHook;
      initialize = _arg.initialize, preInsertHook = _arg.preInsertHook, this.preUpdateHook = _arg.preUpdateHook, preSaveHook = _arg.preSaveHook, postSaveHook = _arg.postSaveHook;
      if (initialize != null) {
        initialize(this);
      }
      if (preInsertHook != null) {
        this.preInsertHooks.push(preInsertHook);
      }
      if (typeof preUpdateHook !== "undefined" && preUpdateHook !== null) {
        this.preUpdateHooks.push(preUpdateHook);
      }
      if (preSaveHook != null) {
        this.preSaveHooks.push(preSaveHook);
      }
      if (postSaveHook != null) {
        return this.postSaveHooks.push(postSaveHook);
      }
    };

    function Collection(key, _arg) {
      var IdAutoInsertionPlugin, plugin, _i, _len, _ref;
      this.key = key;
      this.schema = _arg.schema, this.hasInstance = _arg.hasInstance, this.hasPersistence = _arg.hasPersistence, this.endpoint = _arg.endpoint, this.autoSave = _arg.autoSave, this.plugins = _arg.plugins, this.indexes = _arg.indexes;
      this.init = __bind(this.init, this);
      this.remove = __bind(this.remove, this);
      this.find = __bind(this.find, this);
      this.getById = __bind(this.getById, this);
      this.findById = __bind(this.findById, this);
      this.findOne = __bind(this.findOne, this);
      this.drop = __bind(this.drop, this);
      this.insert = __bind(this.insert, this);
      this.update = __bind(this.update, this);
      this.save = __bind(this.save, this);
      this.saved = __bind(this.saved, this);
      this.loadContent = __bind(this.loadContent, this);
      this.updateInstanceIfNeeded = __bind(this.updateInstanceIfNeeded, this);
      this.load = __bind(this.load, this);
      this.count = __bind(this.count, this);
      this._updateCount = __bind(this._updateCount, this);
      this.updateIndex = __bind(this.updateIndex, this);
      this.resetItemsIndex = __bind(this.resetItemsIndex, this);
      if (this.autoSave == null) {
        this.autoSave = true;
      }
      if (this.hasPersistence == null) {
        this.hasPersistence = true;
      }
      if (this.hasInstance == null) {
        this.hasInstance = true;
      }
      this.preInsertHooks = [];
      this.preUpdateHooks = [];
      this.preSaveHooks = [];
      this.postSaveHooks = [];
      IdAutoInsertionPlugin = {
        preInsertHook: function(item) {
          return item.id != null ? item.id : item.id = uuid();
        }
      };
      this.addPlugin(IdAutoInsertionPlugin);
      if (this.plugins != null) {
        _ref = this.plugins;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          plugin = _ref[_i];
          this.addPlugin(plugin);
        }
      }
      if (!(this.hasInstance || this.hasPersistence)) {
        throw new Error('hasInstance or hasPersistence must be true');
      }
      this._count = 0;
      this._instance = null;
      if (this.indexes == null) {
        this.indexes = ['id'];
      }
      this._indexesData = {};
    }

    Collection.prototype.initIndexes = function() {
      var indexName, _i, _len, _ref, _results;
      _ref = this.indexes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        indexName = _ref[_i];
        _results.push(this.resetItemsIndex(indexName));
      }
      return _results;
    };

    Collection.prototype.resetItemsIndex = function(indexName) {
      var item, _i, _len, _ref, _results;
      this._indexesData[indexName] = {};
      _ref = this._instance;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        _results.push(this.updateIndex(indexName, item[indexName]));
      }
      return _results;
    };

    Collection.prototype.updateIndex = function(indexName, val, index) {
      var indexes;
      indexes = this._indexesData[indexName];
      if (indexes[val] != null) {
        return indexes[val].push(index);
      } else {
        return this._indexesData[indexName][val] = [index];
      }
    };

    Collection.prototype._updateCount = function(_count) {
      this._count = _count;
    };

    Collection.prototype.count = function() {
      return this._count;
    };

    Collection.prototype.load = function() {
      return defer((function(_this) {
        return function(done) {
          return localforage.getItem(_this.key).then(function(content) {
            return done(content);
          });
        };
      })(this));
    };

    Collection.prototype.updateInstanceIfNeeded = function(instance) {
      if (this.hasInstance) {
        return this._instance = instance;
      }
    };

    Collection.prototype.loadContent = function() {
      return defer((function(_this) {
        return function(done) {
          if (_this.hasInstance && _this._instance) {
            return done(_this._instance);
          } else {
            return _this.load().then(function(content) {
              return done(content);
            });
          }
        };
      })(this));
    };

    Collection.prototype.saved = function() {
      return this._saved;
    };

    Collection.prototype.save = function(content) {
      return defer((function(_this) {
        return function(done) {
          var hook, tosave, _i, _len, _ref;
          if (!_this.hasPersistence) {
            throw "`" + _this.key + "` collection doesn't have storage";
          }
          tosave = content != null ? content : _this._instance;
          _ref = _this.preSaveHooks;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            hook = _ref[_i];
            hook(tosave);
          }
          return localforage.setItem(_this.key, tosave).then(function() {
            var _j, _len1, _ref1;
            _this.updateInstanceIfNeeded(tosave);
            _this._saved = true;
            _ref1 = _this.postSaveHooks;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              hook = _ref1[_j];
              hook(tosave);
            }
            return done();
          });
        };
      })(this));
    };

    Collection.prototype.update = function(obj) {
      return defer((function(_this) {
        return function(done) {
          var array;
          array = obj.length != null ? obj : [obj];
          return _this.loadContent().then(function(content) {
            var c, item, key, n, val, _i, _j, _len, _len1;
            for (_i = 0, _len = array.length; _i < _len; _i++) {
              item = array[_i];
              for (n = _j = 0, _len1 = content.length; _j < _len1; n = ++_j) {
                c = content[n];
                if (c.id === item.id) {
                  for (key in item) {
                    val = item[key];
                    content[n][key] = val;
                  }
                  break;
                }
              }
            }
            applyHooks(content, _this.preUpdateHooks);
            _this.updateInstanceIfNeeded(content);
            if (_this.autoSave) {
              return _this.save(content).then(function() {
                return done();
              });
            } else {
              _this._saved = false;
              return done();
            }
          });
        };
      })(this));
    };

    Collection.prototype.insert = function(obj) {
      return defer((function(_this) {
        return function(done) {
          var array, ret;
          array = obj.length ? obj.map(function(i) {
            var ret;
            ret = clone(i);
            return ret;
          }) : (ret = clone(obj), [ret]);
          applyHooks(array, _this.preInsertHooks);
          return _this.loadContent().then(function(content) {
            var beforeIndexLength, i, n, _i, _j, _len, _len1;
            beforeIndexLength = content.length;
            for (_i = 0, _len = array.length; _i < _len; _i++) {
              i = array[_i];
              content.push(i);
            }
            for (n = _j = 0, _len1 = array.length; _j < _len1; n = ++_j) {
              i = array[n];
              _this.updateIndex('id', i.id, beforeIndexLength + n);
            }
            _this._updateCount(content.length);
            if (_this.autoSave) {
              return _this.save().then(function() {
                if (_this.hasInstance) {
                  _this._instance = content;
                }
                return done();
              });
            } else {
              _this._saved = false;
              if (_this.hasInstance) {
                _this._instance = content;
              }
              return done();
            }
          });
        };
      })(this));
    };

    Collection.prototype.drop = function() {
      return defer((function(_this) {
        return function(done) {
          return localforage.setItem(_this.key, '[]').then(function() {
            return done();
          });
        };
      })(this));
    };

    Collection.prototype.findOne = function(func_or_obj) {
      return defer((function(_this) {
        return function(done) {
          return _this.find(func_or_obj).then(function(_arg) {
            var first;
            first = _arg[0];
            return done(first);
          });
        };
      })(this));
    };

    Collection.prototype.findById = function(id) {
      return defer((function(_this) {
        return function(done) {
          var index;
          if (!_this.hasInstance) {
            throw 'need hasInstance';
          }
          index = _this._indexesData['id'][id][0];
          return done(_this._instance[index]);
        };
      })(this));
    };

    Collection.prototype.getById = function(id) {
      var index;
      if (!this.hasInstance) {
        throw 'need hasInstance';
      }
      index = this._indexesData['id'][id][0];
      return this._instance[index];
    };

    Collection.prototype.find = function(func_or_obj) {
      if (func_or_obj == null) {
        func_or_obj = null;
      }
      return defer((function(_this) {
        return function(done) {
          return _this.loadContent().then(function(content) {
            var func, queryObj, results;
            results = func_or_obj == null ? content : (func = func_or_obj) instanceof Function ? content.filter(function(item) {
              return func(item);
            }) : (queryObj = func_or_obj) instanceof Object ? content.filter(function(item) {
              return dequal(queryObj, item);
            }) : void 0;
            return done(results);
          });
        };
      })(this));
    };

    Collection.prototype.remove = function(func_or_obj) {
      var d;
      return d = defer((function(_this) {
        return function(done) {
          var c, loading;
          c = null;
          loading = defer(function(done) {
            return _this.loadContent().then(function(content) {
              c = content;
              return done(content);
            });
          });
          return loading.then(function(content) {
            return _this.find(func_or_obj).then(function(toremove) {
              var remove_ids;
              remove_ids = toremove.map(function(i) {
                return i.id;
              });
              content = content.filter(function(item) {
                var _ref;
                return _ref = item.id, __indexOf.call(remove_ids, _ref) < 0;
              });
              return _this.save(content).then(function() {
                return done();
              });
            });
          });
        };
      })(this));
    };

    Collection.prototype.init = function() {
      return defer((function(_this) {
        return function(done) {
          return localforage.getItem(_this.key, function(content) {
            if (content == null) {
              content = [];
            }
            if (_this.hasInstance) {
              _this._instance = content;
              _this.initIndexes();
            }
            if (_this.hasPersistence) {
              return _this.save(content).then(function() {
                return done();
              });
            } else {
              _this._updateCount(content.length);
              return done();
            }
          });
        };
      })(this));
    };

    return Collection;

  })();

  Momic.DB = (function() {
    DB.prototype.collectionKey = function(collectionName) {
      return this.prefix + '_' + collectionName;
    };

    function DB(opts) {
      this.init = __bind(this.init, this);
      this.collectionKey = __bind(this.collectionKey, this);
      var colOpts, key, _ref;
      this.initialized = false;
      this.prefix = (opts != null ? opts.name : void 0) || '';
      this.storage = (opts != null ? opts.storage : void 0) || 'localforage';
      this.collections = [];
      _ref = opts != null ? opts.collections : void 0;
      for (key in _ref) {
        colOpts = _ref[key];
        this.addCollection(key, colOpts);
      }
    }

    DB.prototype.init = function() {
      return defer((function(_this) {
        return function(done) {
          var inits;
          inits = _this.collections.map(function(col) {
            return col.init();
          });
          return Promise.all(inits).then(function() {
            _this.initialized = true;
            return done();
          });
        };
      })(this));
    };

    DB.prototype.addCollection = function(key, colOpts) {
      if (key === 'initialized' || key === 'prefix' || key === 'storage' || key === 'init' || key === 'collectionKey' || key === 'addCollection') {
        throw new Error("'" + key + "' is reserved word");
      }
      if (colOpts.storage == null) {
        colOpts.storage = this.storage;
      }
      this[key] = new Momic.Collection(this.collectionKey(key), colOpts);
      this.collections.push(this[key]);
      if (this.initialized) {
        return defer((function(_this) {
          return function(done) {
            return _this[key].init().then(function() {
              return done();
            });
          };
        })(this));
      } else {
        return this[key];
      }
    };

    return DB;

  })();

  if ((typeof define) === 'function' && (typeof define.amd) === 'object' && define.amd) {
    define(Momic);
  } else {
    window.Momic = Momic;
  }

}).call(this);
